#!/usr/bin/env python

#

# All rights reserved.
#


#
# Description:
#              Adapted to run in PvS architecture
# Create Date:
#              31.05.2019
#
# @NETFPGA_LICENSE_HEADER_START@
#
# Licensed to NetFPGA C.I.C. (NetFPGA) under one or more contributor
# license agreements.  See the NOTICE file distributed with this work for
# additional information regarding copyright ownership.  NetFPGA licenses this
# file to you under the NetFPGA Hardware-Software License, Version 1.0 (the
# "License"); you may not use this file except in compliance with the
# License.  You may obtain a copy of the License at:
#
#   http://www.netfpga-cic.org
#
# Unless required by applicable law or agreed to in writing, Work distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations under the License.
#
# @NETFPGA_LICENSE_HEADER_END@
#

import sys, os, argparse, subprocess
from collections import OrderedDict

args = None

projName = ""
projDir = ""
projDesignDir = ""
projSume = ""
v_switch = ""
testName = None


def getArgs():
    global args
    parser = argparse.ArgumentParser(prog="pvs", usage="./%(prog)s.py name_p4_switch_0 name_p4_switch_1 ... name_p4_switch_N  [options] [--help]", description="Virtualize P4 Switches with PvS Architecture.")
    parser.add_argument("switches", nargs="+", metavar="<string>", help="The name of first P4 switch to virtualize, i.e: l2_switch, router ")
    parser.add_argument("-name", type=str, metavar="<string>", default=None, help="This will replace the environment variables to match with the given switch name (This flag removes the need to update the P4_PROJECT_NAME variable in setting.sh script).")
    parser.add_argument("-t", action="store_true", help="This will only run gen_testdate_<p4_switch>.py from testdata/ folder to generate packets for test (src.pcap and dst.pcap).")
    parser.add_argument("-c", action="store_true", help="This will only compile <p4_switch>.p4 from src/ folder to verify syntax and create tables.")
    parser.add_argument("-s", action="store_true", help="This will compile, generate testdata and run p4_switch simulation (simulation generated from SDNet with src.pcap and dst.pcap).")
    parser.add_argument("-v", action="store_true", help="Verbose mode. This will show all files initialized.")
    parser.add_argument("--pp", action="store_true", help="This will print all packets generated by gen_testdata. [--print packets]")
    parser.add_argument("--sim", action="store_true", help="This will only run the simulator in command-line mode without testdata update. To interactive mode also pass the --gui argument. To use this, pass project name as argument switches")
    parser.add_argument("--sim_update_testdata", action="store_true", help="This will only run the simulator in command-line mode updating the testdata, i.e. generating need pcap to input in simulation. To interactive mode also pass the --gui argument. To use this, pass project name as argument switches")
    parser.add_argument("--test_name", type=str, metavar="<string>", default="switch_default", help="This will run the test simulation in command line mode to passed argument. To interactive mode also pass the --gui argument. To use this, pass the name of the test simulation created by you, i.e. switch_default or switch_regread")
    parser.add_argument("--gui", action="store_true", help="This will run the simulator in interactive mode (usually with a GUI). If passaed without --sim will run all project building. To use this, pass project name as argument switches")
    parser.add_argument("--imp", action="store_true", help="This will run the synthesis and implementation generating the bitstream file (.bit).")
    parser.add_argument("--imp_only", action="store_true", help="CAUTION:This will run only the implementation. It's required all simulation files.")
    parser.add_argument("--testdata_all", action="store_true", help="This will create testdata files for all switches passed by argument. Need $P4_PROJECT_DIR/testdata/gen_testdata_<P4_SWITCH>.py for all switches passed by argument.")
    parser.add_argument("--open_project", action="store_true", help="Open project for switch design instantiated in $P4_PROJECT_NAME. To use this, pass project name as argument switches")
    parser.add_argument("--open_cli", action="store_true", help="Open CLI (Comand Line Interface) to p4_switch(virtual switch) passed by argument in project folder $P4_PROJECT_DIR or passed by -name flag. To use this, pass project name and the virtual switche name as argument. Support ONLY ONE virtual switch(p4_switch) argument!!!")
    parser.add_argument("--latency", action="store_true", help="Replace simulation packets by /testdata/gen_testdata_<p4_switch>_<#_switches>_latency to calc latency times")
    parser.add_argument("--bandwidth_64", action="store_true", help="Replace simulation packets by /testdata/gen_testdata_<p4_switch>_<#_switches>_bandwidth to calc bandwidth times to packets with 64 bytes of lenght")
    parser.add_argument("--bandwidth_256", action="store_true", help="Replace simulation packets by /testdata/gen_testdata_<p4_switch>_<#_switches>_bandwidth to calc bandwidth times to packets with 256 bytes of lenght")
    parser.add_argument("--bandwidth_1500", action="store_true", help="Replace simulation packets by /testdata/gen_testdata_<p4_switch>_<#_switches>_bandwidth to calc bandwidth times to packets with 1500 bytes of lenght")
    parser.add_argument("--BASE_ADDRESS", type=str, metavar="<hexadecimal>", default="0x44020000", help="The Base Address of virtual switches (base address)")
    args = parser.parse_args()

def setEnv():
    global args; global projName; global projDir; global projDesignDir; global projSume; global testName; global v_switch

    if ( args.name is None ):
        if ( len(args.switches) == 1 ):
            os.environ["P4_PROJECT_NAME"] = str(args.switches[0])
        else: # Get the defined P4_PROJECT_NAME environment variable from settings.sh, if set
            if ("P4_PROJECT_NAME" not in os.environ):
                print("\nThe P4_PROJECT_NAME environment variable or the -name flag must be set!!!\n\n")
                sys.exit(1)
    else:
        os.environ["P4_PROJECT_NAME"] = args.name

    # Adding all switch in one string and export this in environment
    # variables to pass this switches as parameters to tcl
    os.environ["P4_PROJ_SWITCHES"] = ':'.join(args.switches)
    os.environ["P4_PROJECT_DIR"] = os.environ["SUME_SDNET"] + "/projects/" + os.environ["P4_PROJECT_NAME"]
    os.environ["NF_DESIGN_DIR"] = os.environ["P4_PROJECT_DIR"] + "/" + os.environ["NF_PROJECT_NAME"]
    os.environ["PYTHONPATH"] = os.environ["SUME_SDNET"] + "/bin:" + os.environ["SUME_FOLDER"] + "/tools/scripts/:" + os.environ["NF_DESIGN_DIR"] + "/lib/Python:" + os.environ["SUME_FOLDER"] + "/tools/scripts/NFTest"
    os.environ["P4_SWITCH_BASE_ADDR"] = args.BASE_ADDRESS
    os.environ["P4_SWITCH"] = os.environ["P4_PROJECT_NAME"]
    os.environ["PVS_VSWITCH"] = args.switches[0]

    projName = os.environ["P4_PROJECT_NAME"]
    projDir = os.environ["P4_PROJECT_DIR"]
    projDesignDir = os.environ["NF_DESIGN_DIR"]
    projSume = os.environ["SUME_FOLDER"]
    testName = args.test_name.split("_")
    v_switch = os.environ["PVS_VSWITCH"]

def printEnv():
    global args; global projName; global projDir; global projDesignDir; global projSume; global testName; global v_switch
    print("\n---------------------------------------------")
    print("            PvS - Enviroment")
    print("---------------------------------------------\n")
    print("Project Name: "+ projName)
    print("    Parallel Switches: "+ str(len(args.switches)))
    print("    P4 Switches: ")
    i = 0
    for sw in args.switches:
        print("        Switch["+ str(i) +"]: "+ sw)
        i += 1
    print("    Project SUME: "+ projSume)
    print("    Project Dir: "+ projDir)
    print("    Design Dir: "+ projDesignDir)
    print("    Test Dir: "+ projDesignDir + "/test/sim_"+ testName[0] +"_"+ testName[1])
    if (args.open_cli):
        print("    CLI Dir: "+ projDesignDir + "/sw/CLI_"+ v_switch)
    print("    Device: xc7vx690t-3-ffg1761")
    print("    P4 Switch Target: "+ os.environ['NF_PROJECT_NAME'])
    print("\n")

def cleanAll():
    global args
    print("\nCleaning Workdir\n")
    if ( args.v ):
        subprocess.call("rm -rfv .Xil", shell=True)
        subprocess.call("rm -rfv $(find -name *.log -o -name *.jou)", shell=True)
        subprocess.call("rm -rfv "+ projDir +"/sw/API", shell=True)
        subprocess.call("rm -rfv "+ projDir +"/sw/CLI*", shell=True)
        subprocess.call(["make", "-C", projDir, "clean"])
    else:
        subprocess.call("rm -rf .Xil", shell=True)
        subprocess.call("rm -rf $(find -name *.log -o -name *.jou)", shell=True)
        subprocess.call("rm -rf "+ projDir +"/sw/API", shell=True)
        subprocess.call("rm -rf "+ projDir +"/sw/CLI*", shell=True)
        subprocess.call(["make", "-s", "-C", projDir, "clean"])

def initWorkspace(verbose):
    global args; global projName; global projDir; global projDesignDir
    print("\nInitializing Workspace")

    if( args.latency ):
        file_src = projDir +"/testdata/gen_testdata_"+ projName +"_"+ str(len(args.switches)) +"ip_latency.py"
        file_dst = projDir +"/testdata/gen_testdata_"+ projName +".py"
        os_error = subprocess.call("cp "+ verbose + file_src +" "+ file_dst, shell=True)
        if ( 1 == os_error ):
            print("\nFile not find:")
            print("\tSource: "+ file_src)
            print("\tDestination: "+ file_dst +"\n\n")
            sys.exit(1)
    elif ( args.bandwidth_64):
        file_src = projDir +"/testdata/gen_testdata_"+ projName +"_"+ str(len(args.switches)) +"ip_bandwidth_64.py"
        file_dst = projDir +"/testdata/gen_testdata_"+ projName +".py"
        os_error = subprocess.call("cp "+ verbose + file_src +" "+ file_dst, shell=True)
        if ( 1 == os_error ):
            print("\nFile not find:")
            print("\tSource: "+ file_src)
            print("\tDestination: "+ file_dst +"\n\n")
            sys.exit(1)
    elif ( args.bandwidth_256):
        file_src = projDir +"/testdata/gen_testdata_"+ projName +"_"+ str(len(args.switches)) +"ip_bandwidth_256.py"
        file_dst = projDir +"/testdata/gen_testdata_"+ projName +".py"
        os_error = subprocess.call("cp "+ verbose + file_src +" "+ file_dst, shell=True)
        if ( 1 == os_error ):
            print("\nFile not find:")
            print("\tSource: "+ file_src)
            print("\tDestination: "+ file_dst +"\n\n")
            sys.exit(1)
    elif ( args.bandwidth_1500):
        file_src = projDir +"/testdata/gen_testdata_"+ projName +"_"+ str(len(args.switches)) +"ip_bandwidth_1500.py"
        file_dst = projDir +"/testdata/gen_testdata_"+ projName +".py"
        os_error = subprocess.call("cp "+ verbose + file_src +" "+ file_dst, shell=True)
        if ( 1 == os_error ):
            print("\nFile not find:")
            print("\tSource: "+ file_src)
            print("\tDestination: "+ file_dst +"\n\n")
            sys.exit(1)
    elif ( args.testdata_all ):
        print("")
        for idx, p4_switch in enumerate(args.switches):
            file_testdata = projDir +"/testdata/gen_testdata_"+ p4_switch +".py"
            if ( os.path.exists(file_testdata) ):
                if (verbose):
                    print("    Testdata vSwitch"+ str(idx) +" - "+ p4_switch +": gen_testdata_"+ p4_switch +".py\n    File: "+ file_testdata)
            else:
                print("\nTestdata to "+ p4_switch +" not find!!!\n\tFile:"+ file_testdata)
                sys.exit(1)

    file_testdata = projDir +"/testdata/gen_testdata_"+ projName +".py"
    if ( os.path.exists(file_testdata) ):
        if (verbose):
            print("    Main testdata: gen_testdata_"+ projName +".py\n    File: "+ file_testdata +"\n")
    else:
        print("\nProject testdata not find!!!\n\tFile:"+ file_testdata)
        sys.exit(1)

    file_src = projDesignDir +"/hw/hdl/nf_datapath_"+ str(len(args.switches)) +"ip.v"
    file_dst = projDesignDir +"/hw/hdl/nf_datapath.v"
    os_error = subprocess.call("cp "+ verbose + file_src +" "+ file_dst, shell=True)
    if ( 1 == os_error ):
        print("\nFile not find:")
        print("\tSource: "+ file_src)
        print("\tDestination: "+ file_dst +"\n\n")
        sys.exit(1)

    subprocess.call(["mkdir", projDir +"/log"])
    subprocess.call(["mkdir", projDir +"/log/Packets"])
    subprocess.call(["mkdir", projDir +"/config_writes"])

def genTestdata(verbose):
    global args; global projDir
    if ( os.environ["P4_SWITCH"] == projName):
        print("\nGenerating TestData to Project "+ os.environ["P4_SWITCH"] +"\n")
    else:
        print("\nGenerating TestData: Virtual Switch "+ os.environ["P4_SWITCH"] +"\n")
    subprocess.call(["make", "-C", projDir , "gen_testdata"])

    print("")
    subprocess.call("cp "+ verbose + projDir +"/testdata/*.pcap "+ projDir +"/log/Packets/", shell = True)
    subprocess.call("cp "+ verbose + projDir +"/testdata/*.txt "+ projDir +"/log/Packets/", shell = True)

    if ( args.pp ):
        if ( args.v ):
            print("\n    Packets Input:")
            subprocess.call(["tcpdump", "-r", projDir +"/testdata/src.pcap", "-n", "-e", "-#", "-XX", "-t", "-vvv", "-l"])
            print("\n    Packets Expected:")
            subprocess.call(["tcpdump", "-r", projDir +"/testdata/dst.pcap", "-n", "-e", "-#", "-XX", "-t", "-vvv", "-l"])
        else:
            print("\n    Packets Input:")
            subprocess.call(["tcpdump", "-r", projDir +"/testdata/src.pcap", "-n", "-e", "-#", "-t", "-vvv", "-l"])
            print("\n    Packets Expected:")
            subprocess.call(["tcpdump", "-r", projDir +"/testdata/dst.pcap", "-n", "-e", "-#", "-t", "-vvv", "-l"])

def genSource(switch):
    print("\nCompilling IP: "+ switch +"\n")
    subprocess.call(["make", "-C", projDir, "gen_src"])

def buildIp(switch, verbose, idx):
    print("\nBuilding IP: "+ switch +" - vSwitch"+ str(idx))
    subprocess.call([os.environ["PVS_SCRIPTS"] +"/p4_build.sh "+verbose], shell=True)
    subprocess.call(["mv "+ verbose + projDir +"/sw/CLI " + projDir +"/sw/CLI_"+ switch], shell=True)
    if ( not args.v ):
        print("Simulation Result: "+ switch +" - vSwitch"+ str(idx) +"\n")
        subprocess.call("tail -6 "+ projDir +"/log/build_"+ switch +".log | head -n 4", shell=True)

def genConfigWrites(major, minor):
    print("\nGenerating Config Writes:\n")
    if ( args.v ):
        subprocess.call("cat "+ projDir +"/config_writes/confW_* | tee -a "+ projDir +"/config_writes/config_writes.txt", shell=True)
        print("")
    else:
        subprocess.call("cat "+ projDir +"/config_writes/confW_* >> "+ projDir +"/config_writes/config_writes.txt", shell=True)
    subprocess.call("make -C "+ projDir +" gen_config_writes", shell=True)
    subprocess.call("make -C "+ projDesignDir +"/test/sim_"+ major +"_"+ minor +" all", shell=True)

def simSume(major, minor):
    global args; global projSume
    if ( args.gui ):
        print("\nStartting Simulation SUME in GUI mode\n")
        if ( args.v ):
            subprocess.call([projSume +"/tools/scripts/nf_test.py sim --major "+ major +" --minor "+ minor +" --gui | tee -a "+ projDir +"/log/sim_"+ projName +".log"], shell=True)
        else:
            subprocess.call([projSume +"/tools/scripts/nf_test.py sim --major "+ major +" --minor "+ minor +" --gui >> "+ projDir +"/log/sim_"+ projName +".log"], shell=True)
            subprocess.call("tail -31 "+ projDir +"/log/sim_"+ projName +".log", shell=True)
    else:
        print("\nStartting Simulation SUME in commandline mode\n")
        if ( args.v ):
            subprocess.call([projSume +"/tools/scripts/nf_test.py sim --major "+ major +" --minor "+ minor +" | tee -a "+ projDir +"/log/sim_"+ projName +".log"], shell=True)
        else:
            subprocess.call([projSume +"/tools/scripts/nf_test.py sim --major "+ major +" --minor "+ minor +" >> "+ projDir +"/log/sim_"+ projName +".log"], shell=True)
            subprocess.call(["tail -31 "+ projDir +"/log/sim_"+ projName +".log"], shell=True)

def synthImpl(verbose):
    print("\nGenerating Synthesis and Implementation:\n")
    subprocess.call(["make", "-C", projDesignDir, "all"])
    file_src = projDir +"/testdata/config_writes.sh"
    file_dst = projDesignDir +"/bitfiles/"
    subprocess.call("cp "+ verbose + file_src +" "+ file_dst, shell=True)
    file_src = projDesignDir +"/bitfiles/"+ os.environ['NF_PROJECT_NAME'] +".bit"
    file_dst = projDesignDir +"/bitfiles/"+ projName +".bit"
    subprocess.call("mv "+ verbose + file_src +" "+ file_dst, shell=True)

def openProject():
    print("\nOpenning Project: "+ projName +"\n")
    try:
        os_error = subprocess.call(["vivado "+ projDesignDir +"/hw/project/simple_sume_switch.xpr"], shell=True)
    except:
        print("\nProject can't open. Are you sure it exists?")
        print("\tTry open: "+ projDesignDir +"/hw/project/simple_sume_switch.xpr\n\n")
        sys.exit(1)


def main():
    global args; global projName; global projDir; global projDesignDir; global projSume; global testName; global v_switch

    getArgs()

    setEnv()

    printEnv()

    verbose_mode = ""
    if ( args.v ):
        verbose_mode = "-v "

    if ( args.open_project ):
        openProject()
        sys.exit(0)

    file_pcap_src = projDir +"/testdata/src.pcap"
    file_pcap_dst = projDir +"/testdata/dst.pcap"
    if ( args.sim or args.sim_update_testdata):
        initWorkspace(verbose_mode)
        os.environ["P4_SWITCH"] = projName
        if ( not os.path.exists(file_pcap_src) or not os.path.exists(file_pcap_dst)):
            print("\nPcap files not exits, you will need run pvs in normal execution, i.e. without simulation flags")
            print("\tTry ./pvs <vSwitch0> <vSwitch1> -name <project_name>\n\n")
            sys.exit(0)
        if ( args.sim_update_testdata):
            genTestdata(verbose_mode)
        genConfigWrites(testName[0], testName[1])
        simSume(testName[0], testName[1])
        sys.exit(0)

    if ( args.sim_update_testdata ):
        initWorkspace(verbose_mode)
        os.environ["P4_SWITCH"] = projName
        if ( not os.path.exists(file_pcap_src) or not os.path.exists(file_pcap_dst)):
            genTestdata(verbose_mode)
        genConfigWrites(testName[0], testName[1])
        simSume(testName[0], testName[1])
        sys.exit(0)

    # include the CLI folder to path to can import P4_SWITCH_CLI
    CLI_FOLDER = projDir + "/sw/CLI_"+ v_switch
    sys.path.insert(1, CLI_FOLDER)
    if (args.open_cli):
        print("Running CLI to Virtual Switch: "+ v_switch +"\n")
        try:
            import P4_SWITCH_CLI
        except:
            print("\n\n ERROR: CLI file not found! Are you sure that exist? \n\t CLI file: "+ CLI_FOLDER +"/P4_SWITCH_CLI.py\n")
            sys.exit(1)
        P4_SWITCH_CLI.SimpleSumeSwitch().cmdloop()
        print("\nExit of Virtual Switch "+ v_switch +" CLI")
        sys.exit(0)

    # Need environment update: P4_PROJ_SWITCHES
    if ( args.imp_only ):
        synthImpl(verbose_mode)
        sys.exit(0)

    cleanAll()

    initWorkspace(verbose_mode)

    if( args.c and not(args.t) ):
        p4_switch_id = 0
        for p4_switch in args.switches:
            os.environ["P4_SWITCH"] = p4_switch
            os.environ["P4_SWITCH_ID"] = str(p4_switch_id)
            genSource(p4_switch)
            p4_switch_id += 1
        sys.exit(0)

    if( args.t ):
        if ( args.testdata_all ):
            for p4_switch in args.switches:
                os.environ["P4_SWITCH"] = p4_switch
                genTestdata(verbose_mode)
        os.environ["P4_SWITCH"] = projName
        genTestdata(verbose_mode)
        sys.exit(0)

    if ( args.testdata_all ):
        # Need environment update: P4_SWITCH and P4_SWITCH_ID
        for idx, p4_switch in enumerate(args.switches):
            os.environ["P4_SWITCH"] = p4_switch
            os.environ["P4_SWITCH_ID"] = str(idx)
            genTestdata(verbose_mode)
            buildIp(p4_switch, verbose_mode, idx)
        os.environ["P4_SWITCH"] = projName
        genTestdata(verbose_mode)
    else:
        os.environ["P4_SWITCH"] = projName
        genTestdata(verbose_mode)
        for idx, p4_switch in enumerate(args.switches):
            os.environ["P4_SWITCH"] = p4_switch
            os.environ["P4_SWITCH_ID"] = str(idx)
            buildIp(p4_switch, verbose_mode, idx)

    if( args.s ):
        sys.exit(0)

    genConfigWrites(testName[0], testName[1])

    # Need environment update: P4_PROJ_SWITCHES
    simSume(testName[0], testName[1])

    # Need environment update: P4_PROJ_SWITCHES
    if ( args.imp ):
        synthImpl(verbose_mode)


if __name__ == "__main__":
    main()
